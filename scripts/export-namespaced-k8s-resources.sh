#!/usr/bin/env bash

# Kubernetes Resource Exporter
# Description: Exports all namespaced Kubernetes resources from a specified namespace
# Usage: ./export-namespaced-k8s-resources.sh <namespace> [output-directory]
# Example: ./export-namespaced-k8s-resources.sh my-namespace ./backup

set -Eeuo pipefail

# Source shared utilities
SCRIPTDIR=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)
readonly SCRIPTDIR
# shellcheck source=__utils.sh
. "$SCRIPTDIR/__utils.sh"

# Configuration
readonly NAMESPACE="${1:-}"
readonly OUTPUT_DIR="${2:-./k8s-export-$(date +%Y%m%d-%H%M%S)}"
readonly SUMMARY_FILE="summary.txt"
readonly MANIFEST_FILE="all-resources.yaml"

# log_success: bold green text without timestamp/level prefix
log_success() { printf "%s%s%s\n" "$GREEN" "$*" "$RESET"; }

# Usage information
usage() {
    cat << EOF
Usage: $(basename "$0") <namespace> [output-directory]

Export all namespaced Kubernetes resources from a specified namespace.

Arguments:
    namespace           The Kubernetes namespace to export resources from
    output-directory    Optional. Directory to save exported resources
                        Default: ./k8s-export-YYYYMMDD-HHMMSS

Examples:
    $(basename "$0") my-namespace
    $(basename "$0") my-namespace ./backup
    $(basename "$0") production ./prod-backup-\$(date +%Y%m%d)

Requirements:
    - kubectl must be installed and configured
    - Active connection to a Kubernetes cluster
    - Read access to the specified namespace
EOF
}

# Check kubectl connectivity
check_requirements() {
    ensure_commands kubectl

    if ! kubectl cluster-info >/dev/null 2>&1; then
        error "Cannot connect to Kubernetes cluster"
        info "Please check your kubectl configuration and cluster connectivity"
        exit 1
    fi
}

# Validate namespace exists
validate_namespace() {
    local ns="${1}"

    if ! kubectl get namespace "${ns}" >/dev/null 2>&1; then
        error "Namespace '${ns}' does not exist or you don't have access to it"
        info "Available namespaces:"
        kubectl get namespaces -o name 2>/dev/null | sed 's|namespace/||' | sed 's/^/  - /' || echo "  Unable to list namespaces"
        exit 1
    fi
}

# Export a single resource
# Arguments:
#   $1 - resource type
#   $2 - namespace
#   $3 - output directory
# Returns:
#   exported count via stdout
export_resource_type() {
    local resource_type="${1}"
    local namespace="${2}"
    local output_dir="${3}"
    local resource_dir="${output_dir}/${resource_type}"
    local exported_count=0

    # Get resources of this type
    local items
    items="$(kubectl get "${resource_type}" -n "${namespace}" -o name 2>/dev/null || true)"

    if [[ -z "${items}" ]]; then
        printf '0'
        return 0
    fi

    mkdir -p "${resource_dir}"

    # Export each item
    while IFS= read -r item; do
        if [[ -z "${item}" ]]; then
            continue
        fi

        local item_name
        item_name="$(printf '%s' "${item}" | cut -d'/' -f2)"

        # Sanitize filename
        local safe_filename
        safe_filename="$(printf '%s' "${item_name}" | tr '/' '-' | tr ':' '-').yaml"

        debug "  - ${item_name}"

        if kubectl get "${item}" -n "${namespace}" -o yaml > "${resource_dir}/${safe_filename}" 2>/dev/null; then
            ((exported_count++)) || true
        else
            warn "Failed to export ${item}"
        fi
    done <<< "${items}"

    printf '%d' "${exported_count}"
}

# Create combined manifest file
create_combined_manifest() {
    local namespace="${1}"
    local output_dir="${2}"
    local manifest_path="${output_dir}/${MANIFEST_FILE}"

    info "Creating combined manifest file..."

    cat > "${manifest_path}" << EOF
# Kubernetes Resources Export
# Namespace: ${namespace}
# Export Date: $(date -u +"%Y-%m-%d %H:%M:%S UTC")
# Generated by: $(basename "$0")
---
EOF

    # Append all YAML files
    find "${output_dir}" -name "*.yaml" -type f ! -name "${MANIFEST_FILE}" -print0 | \
        while IFS= read -r -d '' yaml_file; do
            printf '\n---\n' >> "${manifest_path}"
            cat "${yaml_file}" >> "${manifest_path}"
        done

    info "Combined manifest saved to: ${manifest_path}"
}

# Create summary report
create_summary() {
    local namespace="${1}"
    local output_dir="${2}"
    local summary_path="${output_dir}/${SUMMARY_FILE}"
    local cluster_info
    cluster_info="$(kubectl config current-context 2>/dev/null || echo "unknown")"

    info "Creating summary report..."

    cat > "${summary_path}" << EOF
Kubernetes Resources Export Summary
====================================

Namespace:        ${namespace}
Cluster Context:  ${cluster_info}
Export Date:      $(date -u +"%Y-%m-%d %H:%M:%S UTC")
Output Directory: ${output_dir}

Exported Resources:
-------------------
EOF

    local total_files=0
    total_files="$(find "${output_dir}" -name "*.yaml" -type f ! -name "${MANIFEST_FILE}" | wc -l | tr -d ' ')"

    printf "Total resource files: %s\n\n" "${total_files}" >> "${summary_path}"

    # List resources by type
    local -a resource_types=()
    local -a resource_counts=()
    mapfile -t dirs < <(find "${output_dir}" -mindepth 1 -maxdepth 1 -type d | sort)
    for dir in "${dirs[@]}"; do
        local resource_type
        resource_type="$(basename "${dir}")"
        local count
        count="$(find "${dir}" -name "*.yaml" -type f | wc -l | tr -d ' ')"
        resource_types+=("${resource_type}")
        resource_counts+=("${count}")
    done

    local max_len=0
    for res in "${resource_types[@]}"; do
        if (( ${#res} > max_len )); then
            max_len=${#res}
        fi
    done

    for i in "${!resource_types[@]}"; do
        printf "  %-${max_len}s : %s\n" "${resource_types[i]}" "${resource_counts[i]}" >> "${summary_path}"
    done

    info "Summary report saved to: ${summary_path}"
}

# Main execution
main() {
    # Parse arguments
    if [[ -z "${NAMESPACE}" ]]; then
        usage
        exit 1
    fi

    if [[ "${NAMESPACE}" == "-h" ]] || [[ "${NAMESPACE}" == "--help" ]]; then
        usage
        exit 0
    fi

    info "Starting Kubernetes resource export..."
    info "Namespace: ${NAMESPACE}"
    info "Output directory: ${OUTPUT_DIR}"

    # Check requirements
    check_requirements

    # Validate namespace
    validate_namespace "${NAMESPACE}"

    # Create output directory
    if [[ -d "${OUTPUT_DIR}" ]]; then
        warn "Output directory already exists: ${OUTPUT_DIR}"
        warn "Files may be overwritten"
    fi
    mkdir -p "${OUTPUT_DIR}"

    # Get all namespaced resource types
    info "Discovering namespaced resource types..."
    local resources
    resources="$(kubectl api-resources --namespaced=true --verbs=list -o name 2>/dev/null | sort -u)"

    if [[ -z "${resources}" ]]; then
        error "Failed to discover resource types"
        exit 1
    fi

    local resource_count
    resource_count="$(printf '%s' "${resources}" | grep -c . || true)"
    info "Found ${resource_count} namespaced resource types"

    # Log discovered resource types
    debug "Resource types available:"
    while IFS= read -r resource; do
        [[ -n "${resource}" ]] && debug "  - ${resource}"
    done <<< "${resources}"
    printf "\n"

    # Export each resource type
    info "Starting resource export..."
    info "========================================"

    local current=0
    while IFS= read -r resource; do
        if [[ -z "${resource}" ]]; then
            continue
        fi

        # Count items to export
        local items
        items="$(kubectl get "${resource}" -n "${NAMESPACE}" -o name 2>/dev/null || true)"
        local item_count=0
        if [[ -n "${items}" ]]; then
            item_count="$(printf '%s' "${items}" | grep -c . || true)"
        fi

        if [[ ${item_count} -gt 0 ]]; then
            info "Exporting ${resource} (${item_count} found)..."
        fi

        local exported_count
        exported_count="$(export_resource_type "${resource}" "${NAMESPACE}" "${OUTPUT_DIR}")"
        ((current++)) || true
        printf "${BLUE}[%3d/%3d]${RESET} " "${current}" "${resource_count}"
        if [[ ${exported_count} -gt 0 ]] 2>/dev/null; then
            printf "✓ ${resource} (${exported_count} exported)\n"
        else
            printf "○ ${resource} (no resources found)\n"
        fi
    done <<< "${resources}"

    info "========================================"

    # Create combined manifest
    create_combined_manifest "${NAMESPACE}" "${OUTPUT_DIR}"

    # Create summary
    create_summary "${NAMESPACE}" "${OUTPUT_DIR}"

    # Display summary
    printf "\n"
    log_success "Export completed successfully to ${OUTPUT_DIR}!"
    printf "\n"
    cat "${OUTPUT_DIR}/${SUMMARY_FILE}"
    printf "\n"
}

# Run main function
main "$@"
